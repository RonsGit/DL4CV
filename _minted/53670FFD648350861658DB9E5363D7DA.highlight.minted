\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MaskedConv2d}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{.}\PYG{n}{Conv2d}\PYG{p}{)}\PYG{p}{:}
\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{in\PYGZus{}channels}\PYG{p}{,} \PYG{n}{out\PYGZus{}channels}\PYG{p}{,} \PYG{n}{kernel\PYGZus{}size}\PYG{p}{,} \PYG{n}{mask\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{c+c1}{\PYGZsh{} Zero padding and no pooling are used to maintain spatial size}
\PYG{n+nb}{super}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{in\PYGZus{}channels}\PYG{p}{,} \PYG{n}{out\PYGZus{}channels}\PYG{p}{,}
\PYG{n}{kernel\PYGZus{}size}\PYG{p}{,} \PYG{n}{padding}\PYG{o}{=}\PYG{n}{kernel\PYGZus{}size} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{k}{assert} \PYG{n}{mask\PYGZus{}type} \PYG{o+ow}{in} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Create a binary mask the same shape as conv weights}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{register\PYGZus{}buffer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mask}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{ones\PYGZus{}like}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{kH}\PYG{p}{,} \PYG{n}{kW} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{kernel\PYGZus{}size}  \PYG{c+c1}{\PYGZsh{} Kernel height and width}
\PYG{n}{yc}\PYG{p}{,} \PYG{n}{xc} \PYG{o}{=} \PYG{n}{kH} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{kW} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}  \PYG{c+c1}{\PYGZsh{} (yc, xc) is the center of the kernel — the \PYGZdq{}current\PYGZdq{} pixel (r,c)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Masking Strategy \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{c+c1}{\PYGZsh{} Zero out all positions below the current row}
\PYG{c+c1}{\PYGZsh{} That is: (r+1, :, :) and beyond — future rows}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{yc}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{} In the current row (yc), zero out pixels to the right}
\PYG{c+c1}{\PYGZsh{} For \PYGZsq{}A\PYGZsq{}: block (r,c) itself and all future columns =\PYGZgt{} mask[:, :, yc, xc:] = 0}
\PYG{c+c1}{\PYGZsh{} For \PYGZsq{}B\PYGZsq{}: allow access to (r,c), only block strictly future columns =\PYGZgt{} mask[:, :, yc, xc+1:] = 0}
\PYG{k}{if} \PYG{n}{mask\PYGZus{}type} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{yc}\PYG{p}{,} \PYG{n}{xc}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} Include current pixel (r,c) in the block}
\PYG{k}{else}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} mask\PYGZus{}type == \PYGZsq{}B\PYGZsq{}}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mask}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{yc}\PYG{p}{,} \PYG{n}{xc}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} Only block pixels strictly right of (r,c)}

\PYG{k}{def} \PYG{n+nf}{forward}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{c+c1}{\PYGZsh{} Apply the mask to the convolution weights before use}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{weight}\PYG{o}{.}\PYG{n}{data} \PYG{o}{*}\PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mask}
\PYG{k}{return} \PYG{n+nb}{super}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{MintedVerbatim}
