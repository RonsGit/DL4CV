\begin{MintedVerbatim}[commandchars=\\\{\}]
	\PYG{c+c1}{\PYGZsh{} Example: PyTorch Linear Probe Setup}
	
	\PYG{k+kn}{import} \PYG{n+nn}{torch}
	\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{nn} \PYG{k}{as} \PYG{n+nn}{nn}
	\PYG{k+kn}{import} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{optim} \PYG{k}{as} \PYG{n+nn}{optim}
	\PYG{k+kn}{from} \PYG{n+nn}{torch}\PYG{n+nn}{.}\PYG{n+nn}{optim}\PYG{n+nn}{.}\PYG{n+nn}{lr\PYGZus{}scheduler} \PYG{k+kn}{import} \PYG{n}{CosineAnnealingLR}
	
	\PYG{c+c1}{\PYGZsh{} Assume backbone is a pretrained model with an attribute output\PYGZus{}dim}
	\PYG{c+c1}{\PYGZsh{} and produces a feature vector of that size.}
	\PYG{n}{backbone} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} e.g., backbone = torchvision.models.resnet50(pretrained=True)}
	\PYG{n}{backbone\PYGZus{}output\PYGZus{}dim} \PYG{o}{=} \PYG{n}{backbone}\PYG{o}{.}\PYG{n}{fc}\PYG{o}{.}\PYG{n}{in\PYGZus{}features}  \PYG{c+c1}{\PYGZsh{} example for ResNet}
	\PYG{n}{backbone}\PYG{o}{.}\PYG{n}{fc} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Identity}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} remove the classification head if needed}
	
	\PYG{c+c1}{\PYGZsh{} Freeze backbone parameters}
	\PYG{k}{for} \PYG{n}{param} \PYG{o+ow}{in} \PYG{n}{backbone}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{param}\PYG{o}{.}\PYG{n}{requires\PYGZus{}grad} \PYG{o}{=} \PYG{k+kc}{False}
	
	\PYG{c+c1}{\PYGZsh{} Define a linear classification head}
	\PYG{n}{num\PYGZus{}classes} \PYG{o}{=} \PYG{l+m+mi}{100}  \PYG{c+c1}{\PYGZsh{} set according to your task}
	\PYG{n}{head} \PYG{o}{=} \PYG{n}{nn}\PYG{o}{.}\PYG{n}{Linear}\PYG{p}{(}\PYG{n}{backbone\PYGZus{}output\PYGZus{}dim}\PYG{p}{,} \PYG{n}{num\PYGZus{}classes}\PYG{p}{)}
	
	\PYG{c+c1}{\PYGZsh{} Move models to device}
	\PYG{n}{device} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cuda}\PYG{l+s+s2}{\PYGZdq{}} \PYG{k}{if} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{cuda}\PYG{o}{.}\PYG{n}{is\PYGZus{}available}\PYG{p}{(}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cpu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{backbone}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{device}\PYG{p}{)}
	\PYG{n}{head}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{device}\PYG{p}{)}
	
	\PYG{c+c1}{\PYGZsh{} Optimizer for head only}
	\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{optim}\PYG{o}{.}\PYG{n}{SGD}\PYG{p}{(}\PYG{n}{head}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lr}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{momentum}\PYG{o}{=}\PYG{l+m+mf}{0.9}\PYG{p}{)}
	\PYG{n}{scheduler} \PYG{o}{=} \PYG{n}{CosineAnnealingLR}\PYG{p}{(}\PYG{n}{optimizer}\PYG{p}{,} \PYG{n}{T\PYGZus{}max}\PYG{o}{=}\PYG{l+m+mi}{90}\PYG{p}{)}
\end{MintedVerbatim}
